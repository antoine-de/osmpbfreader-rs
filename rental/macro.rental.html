<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `rental` macro in crate `rental`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, rental">

    <title>rental::rental - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc macro">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>rental</a></p><script>window.sidebarCurrent = {name: 'rental', ty: 'macro', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Macro <a href='index.html'>rental</a>::<wbr><a class="macro" href=''>rental</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/rental/lib.rs.html#198-253' title='goto source code'>[src]</a></span></h1>
<pre class="rust macro">
<span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">rental</span> {
    {
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
		<span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span>:<span class="ident">ident</span> {
			$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">tt</span>)<span class="op">*</span>
		}
	} <span class="op">=&gt;</span> { ... };
    {
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
		<span class="kw">pub</span> <span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span>:<span class="ident">ident</span> {
			$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">tt</span>)<span class="op">*</span>
		}
	} <span class="op">=&gt;</span> { ... };
    {
		$(<span class="attribute">#[<span class="macro-nonterminal">$</span><span class="macro-nonterminal">attr</span>:<span class="ident">meta</span>]</span>)<span class="op">*</span>
		<span class="kw">pub</span>($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">vis</span>:<span class="ident">tt</span>)<span class="kw-2">*</span>) <span class="kw">mod</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">rental_mod</span>:<span class="ident">ident</span> {
			$(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">body</span>:<span class="ident">tt</span>)<span class="op">*</span>
		}
	} <span class="op">=&gt;</span> { ... };
}</pre>
<div class='docblock'><p>The core of this crate, this macro will generate self-referential structs.</p>

<p>This macro is invoked in item position. The body parses as valid rust and contains no special syntax. Only certain constructs are allowed, and a few special attributes and lifetimes are recognized.</p>

<p>To start, the the top level item of the macro invocation must be a single module. This module will contain all items that the macro generates and export them to you. Within the module, only three types of items are accepted: <code>use</code> statements, type aliases, and struct definitions. The <code>use</code> statements and type aliases are passed directly through with no special consideration; the primary concern is the struct definitions.</p>

<p>First, all struct definitions must have a <code>#[rental]</code> or <code>#[rental_mut]</code> attribute to indicate that they are self-referential. These attributes may optionally take the arguments <code>debug_borrow</code>, <code>deref_suffix</code>, and <code>deref_mut_suffix</code>, discussed below.</p>

<p>Next, the structs must have named fields (no tuple structs) and they must have at least 2 fields, since a struct with 1 field can&#39;t meaningfully reference itself anyway.</p>

<p>The order of the fields is significant, as they are declared in order of least to most dependent. The first field, also referred to as the &quot;head&quot; of the struct, contains no self-references, the second field may borrow the first, the third field may borrow the second or first, and so on. The chain of fields after the head is called the &quot;tail&quot;.</p>

<p>Because rental structs are self-referential, special care is taken to ensure that moving the struct will not invalidate any internal references. This is accomplished by requiring all fields but the last one, collectively known as the &quot;prefix&quot; of the struct, to implement <a href="https://crates.io/crates/stable_deref_trait"><code>StableDeref</code></a>. This is not required for the final field of the struct, known as the &quot;suffix&quot;, since nothing holds a reference to it.</p>

<p>NOTE: Because of a workaround for a compiler bug, rental might not always correctly determine the <code>Deref::Target</code> type of your prefix fields. If you receive type errors when compiling, you can try using the <code>target_ty_hack</code> attribute on the field of the struct. Set this attribute equal to a string that names the correct target type (e.g. <code>#[target_ty_hack = &quot;[u8]&quot;]</code> for <code>Vec&lt;u8&gt;</code>.</p>

<p>Each field that you declare creates a special lifetime of the same name that can be used by later fields to borrow it. This is how the referential relationships are established in the struct definition.</p>

<p>This is a all a bit to chew on so far, so let&#39;s stop and take a look at an example:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Foo</span> { <span class="ident">i</span>: <span class="ident">i32</span> }
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Bar</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="ident">foo</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Foo</span> }
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Qux</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>: <span class="lifetime">&#39;b</span>, <span class="lifetime">&#39;b</span><span class="op">&gt;</span> { <span class="ident">bar</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">Bar</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> }
 
<span class="macro">rental</span><span class="macro">!</span> {
    <span class="kw">mod</span> <span class="ident">my_rentals</span> {
        <span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;

        <span class="attribute">#[<span class="ident">rental</span>]</span>
        <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyRental</span> {
            <span class="ident">foo</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Foo</span><span class="op">&gt;</span>,
            <span class="ident">bar</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Bar</span><span class="op">&lt;</span><span class="lifetime">&#39;foo</span><span class="op">&gt;&gt;</span>,
            <span class="ident">qux</span>: <span class="ident">Qux</span><span class="op">&lt;</span><span class="lifetime">&#39;foo</span>, <span class="lifetime">&#39;bar</span><span class="op">&gt;</span>,
        }
    }
}</pre>

<p>Here we see each field use the special lifetimes of the previous fields to establish the borrowing chain.</p>

<p>In addition to the rental struct itself, two other structs are generated, with <code>_Borrow</code> and <code>_BorrowMut</code> appended to the original struct name (e.g. <code>MyRental_Borrow</code> and <code>MyRental_BorrowMut</code>). These structs contain the same fields as the original struct, but are borrows of the originals. These structs are passed into certain closures that you provide to allow you access to underlying struct data. For mutable rentals, these structs will only contain a borrow of the suffix; the other fields will be erased with <code>PhantomData</code>.</p>

<p>If all the fields of your struct implement <code>Debug</code> then you can use the <code>debug_borrow</code> option on the rental attribute to gain a <code>Debug</code> impl on the struct itself. Also, if the suffix field of the struct implements <code>Deref</code> or <code>DerefMut</code>, you can add a <code>deref_suffix</code> or <code>deref_mut_suffix</code> argument to the <code>rental</code> attribute on the struct. This will generate a <code>Deref</code> implementation for the rental struct itself that will deref through the suffix and return the borrow to you, for convenience. Note, however, that this will only be legal if none of the special rental lifetimes appear in the type signature of the deref target. If they do, exposing them to the outside world could result in unsafety, so this is not allowed and such a scenario will not compile.</p>

<p>Finally, there is one other capability to discuss. If a rental struct has been defined elsewhere, either in our own crate or in a dependency, we&#39;d like to be able to chain our own rental struct off of it. In this way, we can use another rental struct as a sort of pre-packaged prefix of our own. As a variation on the above example, it would look like this:</p>

<pre class="rust rust-example-rendered">
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Foo</span> { <span class="ident">i</span>: <span class="ident">i32</span> }
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Bar</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> { <span class="ident">foo</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">Foo</span> }
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Qux</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>: <span class="lifetime">&#39;b</span>, <span class="lifetime">&#39;b</span><span class="op">&gt;</span> { <span class="ident">bar</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b</span> <span class="ident">Bar</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> }
 
<span class="macro">rental</span><span class="macro">!</span> {
    <span class="kw">mod</span> <span class="ident">my_rentals</span> {
        <span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;

        <span class="attribute">#[<span class="ident">rental</span>]</span>
        <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">OtherRental</span> {
            <span class="ident">foo</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Foo</span><span class="op">&gt;</span>,
            <span class="ident">bar</span>: <span class="ident">Bar</span><span class="op">&lt;</span><span class="lifetime">&#39;foo</span><span class="op">&gt;</span>,
        }
         
        <span class="attribute">#[<span class="ident">rental</span>]</span>
        <span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyRental</span> {
            <span class="attribute">#[<span class="ident">subrental</span>(<span class="ident">arity</span> <span class="op">=</span> <span class="number">2</span>)]</span>
            <span class="ident">prefix</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">OtherRental</span><span class="op">&gt;</span>,
            <span class="ident">qux</span>: <span class="ident">Qux</span><span class="op">&lt;</span><span class="lifetime">&#39;prefix_0</span>, <span class="lifetime">&#39;prefix_1</span><span class="op">&gt;</span>,
        }
    }
}</pre>

<p>The first rental struct is fairly standard, so we&#39;ll focus on the second one. The head field is given a <code>subrental</code> attribute with an <code>arity</code> argument. The arity of a rental struct is the number of special lifetimes it creates. As can be seen above, the first struct has two fields, neither of which is itself a subrental, so it has an arity of 2. The arity of the second struct would be 3, since it includes the two fields of the first rental as well as one new one. In this way, arity is transitive. So if we used our new struct itself as a subrental of yet another struct, we&#39;d need to declare the field with <code>arity = 3</code>. The special lifetimes created by a subrental are the field name followed by a <code>_</code> and a zero-based index.</p>

<p>This covers the essential capabilities of the macro itself. For details on the API of the structs themselves, see the <a href="examples/index.html"><code>examples</code></a> module.</p>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "rental";
    </script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>